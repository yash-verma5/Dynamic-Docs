prompt = "<purpose>\nExecute all plans in a phase using wave-based parallel execution. Orchestrator stays lean — delegates plan execution to subagents.\n</purpose>\n\n<core_principle>\nOrchestrator coordinates, not executes. Each subagent loads the full execute-plan context. Orchestrator: discover plans → analyze deps → group waves → spawn agents → handle checkpoints → collect results.\n</core_principle>\n\n<required_reading>\nRead STATE.md before any operation to load project context.\n</required_reading>\n\n<process>\n\n<step name=\"initialize\" priority=\"first\">\nLoad all context in one call:\n\n```bash\nINIT=$(node ./.gemini/get-shit-done/bin/gsd-tools.cjs init execute-phase \"${PHASE_ARG}\")\n```\n\nParse JSON for: `executor_model`, `verifier_model`, `commit_docs`, `parallelization`, `branching_strategy`, `branch_name`, `phase_found`, `phase_dir`, `phase_number`, `phase_name`, `phase_slug`, `plans`, `incomplete_plans`, `plan_count`, `incomplete_count`, `state_exists`, `roadmap_exists`.\n\n**If `phase_found` is false:** Error — phase directory not found.\n**If `plan_count` is 0:** Error — no plans found in phase.\n**If `state_exists` is false but `.planning/` exists:** Offer reconstruct or continue.\n\nWhen `parallelization` is false, plans within a wave execute sequentially.\n</step>\n\n<step name=\"handle_branching\">\nCheck `branching_strategy` from init:\n\n**\"none\":** Skip, continue on current branch.\n\n**\"phase\" or \"milestone\":** Use pre-computed `branch_name` from init:\n```bash\ngit checkout -b \"$BRANCH_NAME\" 2>/dev/null || git checkout \"$BRANCH_NAME\"\n```\n\nAll subsequent commits go to this branch. User handles merging.\n</step>\n\n<step name=\"validate_phase\">\nFrom init JSON: `phase_dir`, `plan_count`, `incomplete_count`.\n\nReport: \"Found {plan_count} plans in {phase_dir} ({incomplete_count} incomplete)\"\n</step>\n\n<step name=\"discover_and_group_plans\">\nLoad plan inventory with wave grouping in one call:\n\n```bash\nPLAN_INDEX=$(node ./.gemini/get-shit-done/bin/gsd-tools.cjs phase-plan-index \"${PHASE_NUMBER}\")\n```\n\nParse JSON for: `phase`, `plans[]` (each with `id`, `wave`, `autonomous`, `objective`, `files_modified`, `task_count`, `has_summary`), `waves` (map of wave number → plan IDs), `incomplete`, `has_checkpoints`.\n\n**Filtering:** Skip plans where `has_summary: true`. If `--gaps-only`: also skip non-gap_closure plans. If all filtered: \"No matching incomplete plans\" → exit.\n\nReport:\n```\n## Execution Plan\n\n**Phase {X}: {Name}** — {total_plans} plans across {wave_count} waves\n\n| Wave | Plans | What it builds |\n|------|-------|----------------|\n| 1 | 01-01, 01-02 | {from plan objectives, 3-8 words} |\n| 2 | 01-03 | ... |\n```\n</step>\n\n<step name=\"execute_waves\">\nExecute each wave in sequence. Within a wave: parallel if `PARALLELIZATION=true`, sequential if `false`.\n\n**For each wave:**\n\n1. **Describe what's being built (BEFORE spawning):**\n\n   Read each plan's `<objective>`. Extract what's being built and why.\n\n   ```\n   ---\n   ## Wave {N}\n\n   **{Plan ID}: {Plan Name}**\n   {2-3 sentences: what this builds, technical approach, why it matters}\n\n   Spawning {count} agent(s)...\n   ---\n   ```\n\n   - Bad: \"Executing terrain generation plan\"\n   - Good: \"Procedural terrain generator using Perlin noise — creates height maps, biome zones, and collision meshes. Required before vehicle physics can interact with ground.\"\n\n2. **Spawn executor agents:**\n\n   Pass paths only — executors read files themselves with their fresh 200k context.\n   This keeps orchestrator context lean (~10-15%).\n\n   ```\n   Task(\n     subagent_type=\"gsd-executor\",\n     model=\"{executor_model}\",\n     prompt=\"\n       <objective>\n       Execute plan {plan_number} of phase {phase_number}-{phase_name}.\n       Commit each task atomically. Create SUMMARY.md. Update STATE.md and ROADMAP.md.\n       </objective>\n\n       <execution_context>\n       @./.gemini/get-shit-done/workflows/execute-plan.md\n       @./.gemini/get-shit-done/templates/summary.md\n       @./.gemini/get-shit-done/references/checkpoints.md\n       @./.gemini/get-shit-done/references/tdd.md\n       </execution_context>\n\n       <files_to_read>\n       Read these files at execution start using the Read tool:\n       - {phase_dir}/{plan_file} (Plan)\n       - .planning/STATE.md (State)\n       - .planning/config.json (Config, if exists)\n       - ./CLAUDE.md (Project instructions, if exists — follow project-specific guidelines and coding conventions)\n       - .agents/skills/ (Project skills, if exists — list skills, read SKILL.md for each, follow relevant rules during implementation)\n       </files_to_read>\n\n       <success_criteria>\n       - [ ] All tasks executed\n       - [ ] Each task committed individually\n       - [ ] SUMMARY.md created in plan directory\n       - [ ] STATE.md updated with position and decisions\n       - [ ] ROADMAP.md updated with plan progress (via `roadmap update-plan-progress`)\n       </success_criteria>\n     \"\n   )\n   ```\n\n3. **Wait for all agents in wave to complete.**\n\n4. **Report completion — spot-check claims first:**\n\n   For each SUMMARY.md:\n   - Verify first 2 files from `key-files.created` exist on disk\n   - Check `git log --oneline --all --grep=\"{phase}-{plan}\"` returns ≥1 commit\n   - Check for `## Self-Check: FAILED` marker\n\n   If ANY spot-check fails: report which plan failed, route to failure handler — ask \"Retry plan?\" or \"Continue with remaining waves?\"\n\n   If pass:\n   ```\n   ---\n   ## Wave {N} Complete\n\n   **{Plan ID}: {Plan Name}**\n   {What was built — from SUMMARY.md}\n   {Notable deviations, if any}\n\n   {If more waves: what this enables for next wave}\n   ---\n   ```\n\n   - Bad: \"Wave 2 complete. Proceeding to Wave 3.\"\n   - Good: \"Terrain system complete — 3 biome types, height-based texturing, physics collision meshes. Vehicle physics (Wave 3) can now reference ground surfaces.\"\n\n5. **Handle failures:**\n\n   **Known Claude Code bug (classifyHandoffIfNeeded):** If an agent reports \"failed\" with error containing `classifyHandoffIfNeeded is not defined`, this is a Claude Code runtime bug — not a GSD or agent issue. The error fires in the completion handler AFTER all tool calls finish. In this case: run the same spot-checks as step 4 (SUMMARY.md exists, git commits present, no Self-Check: FAILED). If spot-checks PASS → treat as **successful**. If spot-checks FAIL → treat as real failure below.\n\n   For real failures: report which plan failed → ask \"Continue?\" or \"Stop?\" → if continue, dependent plans may also fail. If stop, partial completion report.\n\n6. **Execute checkpoint plans between waves** — see `<checkpoint_handling>`.\n\n7. **Proceed to next wave.**\n</step>\n\n<step name=\"checkpoint_handling\">\nPlans with `autonomous: false` require user interaction.\n\n**Auto-mode checkpoint handling:**\n\nRead auto-advance config:\n```bash\nAUTO_CFG=$(node ./.gemini/get-shit-done/bin/gsd-tools.cjs config-get workflow.auto_advance 2>/dev/null || echo \"false\")\n```\n\nWhen executor returns a checkpoint AND `AUTO_CFG` is `\"true\"`:\n- **human-verify** → Auto-spawn continuation agent with `{user_response}` = `\"approved\"`. Log `⚡ Auto-approved checkpoint`.\n- **decision** → Auto-spawn continuation agent with `{user_response}` = first option from checkpoint details. Log `⚡ Auto-selected: [option]`.\n- **human-action** → Present to user (existing behavior below). Auth gates cannot be automated.\n\n**Standard flow (not auto-mode, or human-action type):**\n\n1. Spawn agent for checkpoint plan\n2. Agent runs until checkpoint task or auth gate → returns structured state\n3. Agent return includes: completed tasks table, current task + blocker, checkpoint type/details, what's awaited\n4. **Present to user:**\n   ```\n   ## Checkpoint: [Type]\n\n   **Plan:** 03-03 Dashboard Layout\n   **Progress:** 2/3 tasks complete\n\n   [Checkpoint Details from agent return]\n   [Awaiting section from agent return]\n   ```\n5. User responds: \"approved\"/\"done\" | issue description | decision selection\n6. **Spawn continuation agent (NOT resume)** using continuation-prompt.md template:\n   - `{completed_tasks_table}`: From checkpoint return\n   - `{resume_task_number}` + `{resume_task_name}`: Current task\n   - `{user_response}`: What user provided\n   - `{resume_instructions}`: Based on checkpoint type\n7. Continuation agent verifies previous commits, continues from resume point\n8. Repeat until plan completes or user stops\n\n**Why fresh agent, not resume:** Resume relies on internal serialization that breaks with parallel tool calls. Fresh agents with explicit state are more reliable.\n\n**Checkpoints in parallel waves:** Agent pauses and returns while other parallel agents may complete. Present checkpoint, spawn continuation, wait for all before next wave.\n</step>\n\n<step name=\"aggregate_results\">\nAfter all waves:\n\n```markdown\n## Phase {X}: {Name} Execution Complete\n\n**Waves:** {N} | **Plans:** {M}/{total} complete\n\n| Wave | Plans | Status |\n|------|-------|--------|\n| 1 | plan-01, plan-02 | ✓ Complete |\n| CP | plan-03 | ✓ Verified |\n| 2 | plan-04 | ✓ Complete |\n\n### Plan Details\n1. **03-01**: [one-liner from SUMMARY.md]\n2. **03-02**: [one-liner from SUMMARY.md]\n\n### Issues Encountered\n[Aggregate from SUMMARYs, or \"None\"]\n```\n</step>\n\n<step name=\"close_parent_artifacts\">\n**For decimal/polish phases only (X.Y pattern):** Close the feedback loop by resolving parent UAT and debug artifacts.\n\n**Skip if** phase number has no decimal (e.g., `3`, `04`) — only applies to gap-closure phases like `4.1`, `03.1`.\n\n**1. Detect decimal phase and derive parent:**\n```bash\n# Check if phase_number contains a decimal\nif [[ \"$PHASE_NUMBER\" == *.* ]]; then\n  PARENT_PHASE=\"${PHASE_NUMBER%%.*}\"\nfi\n```\n\n**2. Find parent UAT file:**\n```bash\nPARENT_INFO=$(node ./.gemini/get-shit-done/bin/gsd-tools.cjs find-phase \"${PARENT_PHASE}\" --raw)\n# Extract directory from PARENT_INFO JSON, then find UAT file in that directory\n```\n\n**If no parent UAT found:** Skip this step (gap-closure may have been triggered by VERIFICATION.md instead).\n\n**3. Update UAT gap statuses:**\n\nRead the parent UAT file's `## Gaps` section. For each gap entry with `status: failed`:\n- Update to `status: resolved`\n\n**4. Update UAT frontmatter:**\n\nIf all gaps now have `status: resolved`:\n- Update frontmatter `status: diagnosed` → `status: resolved`\n- Update frontmatter `updated:` timestamp\n\n**5. Resolve referenced debug sessions:**\n\nFor each gap that has a `debug_session:` field:\n- Read the debug session file\n- Update frontmatter `status:` → `resolved`\n- Update frontmatter `updated:` timestamp\n- Move to resolved directory:\n```bash\nmkdir -p .planning/debug/resolved\nmv .planning/debug/{slug}.md .planning/debug/resolved/\n```\n\n**6. Commit updated artifacts:**\n```bash\nnode ./.gemini/get-shit-done/bin/gsd-tools.cjs commit \"docs(phase-${PARENT_PHASE}): resolve UAT gaps and debug sessions after ${PHASE_NUMBER} gap closure\" --files .planning/phases/*${PARENT_PHASE}*/*-UAT.md .planning/debug/resolved/*.md\n```\n</step>\n\n<step name=\"verify_phase_goal\">\nVerify phase achieved its GOAL, not just completed tasks.\n\n```bash\nPHASE_REQ_IDS=$(node ./.gemini/get-shit-done/bin/gsd-tools.cjs roadmap get-phase \"${PHASE_NUMBER}\" | jq -r '.section' | grep -i \"Requirements:\" | sed 's/.*Requirements:\\*\\*\\s*//' | sed 's/[\\[\\]]//g')\n```\n\n```\nTask(\n  prompt=\"Verify phase {phase_number} goal achievement.\nPhase directory: {phase_dir}\nPhase goal: {goal from ROADMAP.md}\nPhase requirement IDs: {phase_req_ids}\nCheck must_haves against actual codebase.\nCross-reference requirement IDs from PLAN frontmatter against REQUIREMENTS.md — every ID MUST be accounted for.\nCreate VERIFICATION.md.\",\n  subagent_type=\"gsd-verifier\",\n  model=\"{verifier_model}\"\n)\n```\n\nRead status:\n```bash\ngrep \"^status:\" \"$PHASE_DIR\"/*-VERIFICATION.md | cut -d: -f2 | tr -d ' '\n```\n\n| Status | Action |\n|--------|--------|\n| `passed` | → update_roadmap |\n| `human_needed` | Present items for human testing, get approval or feedback |\n| `gaps_found` | Present gap summary, offer `/gsd:plan-phase {phase} --gaps` |\n\n**If human_needed:**\n```\n## ✓ Phase {X}: {Name} — Human Verification Required\n\nAll automated checks passed. {N} items need human testing:\n\n{From VERIFICATION.md human_verification section}\n\n\"approved\" → continue | Report issues → gap closure\n```\n\n**If gaps_found:**\n```\n## ⚠ Phase {X}: {Name} — Gaps Found\n\n**Score:** {N}/{M} must-haves verified\n**Report:** {phase_dir}/{phase_num}-VERIFICATION.md\n\n### What's Missing\n{Gap summaries from VERIFICATION.md}\n\n---\n## ▶ Next Up\n\n`/gsd:plan-phase {X} --gaps`\n\n*(`/clear` first → fresh context window)*\n\nAlso: `cat {phase_dir}/{phase_num}-VERIFICATION.md` — full report\nAlso: `/gsd:verify-work {X}` — manual testing first\n```\n\nGap closure cycle: `/gsd:plan-phase {X} --gaps` reads VERIFICATION.md → creates gap plans with `gap_closure: true` → user runs `/gsd:execute-phase {X} --gaps-only` → verifier re-runs.\n</step>\n\n<step name=\"update_roadmap\">\n**Mark phase complete and update all tracking files:**\n\n```bash\nCOMPLETION=$(node ./.gemini/get-shit-done/bin/gsd-tools.cjs phase complete \"${PHASE_NUMBER}\")\n```\n\nThe CLI handles:\n- Marking phase checkbox `[x]` with completion date\n- Updating Progress table (Status → Complete, date)\n- Updating plan count to final\n- Advancing STATE.md to next phase\n- Updating REQUIREMENTS.md traceability\n\nExtract from result: `next_phase`, `next_phase_name`, `is_last_phase`.\n\n```bash\nnode ./.gemini/get-shit-done/bin/gsd-tools.cjs commit \"docs(phase-{X}): complete phase execution\" --files .planning/ROADMAP.md .planning/STATE.md .planning/REQUIREMENTS.md {phase_dir}/*-VERIFICATION.md\n```\n</step>\n\n<step name=\"offer_next\">\n\n**Exception:** If `gaps_found`, the `verify_phase_goal` step already presents the gap-closure path (`/gsd:plan-phase {X} --gaps`). No additional routing needed — skip auto-advance.\n\n**Auto-advance detection:**\n\n1. Parse `--auto` flag from $ARGUMENTS\n2. Read `workflow.auto_advance` from config:\n   ```bash\n   AUTO_CFG=$(node ./.gemini/get-shit-done/bin/gsd-tools.cjs config-get workflow.auto_advance 2>/dev/null || echo \"false\")\n   ```\n\n**If `--auto` flag present OR `AUTO_CFG` is true (AND verification passed with no gaps):**\n\n```\n╔══════════════════════════════════════════╗\n║  AUTO-ADVANCING → TRANSITION             ║\n║  Phase {X} verified, continuing chain    ║\n╚══════════════════════════════════════════╝\n```\n\nExecute the transition workflow inline (do NOT use Task — orchestrator context is ~10-15%, transition needs phase completion data already in context):\n\nRead and follow `./.gemini/get-shit-done/workflows/transition.md`, passing through the `--auto` flag so it propagates to the next phase invocation.\n\n**If neither `--auto` nor `AUTO_CFG` is true:**\n\nThe workflow ends. The user runs `/gsd:progress` or invokes the transition workflow manually.\n</step>\n\n</process>\n\n<context_efficiency>\nOrchestrator: ~10-15% context. Subagents: fresh 200k each. No polling (Task blocks). No context bleed.\n</context_efficiency>\n\n<failure_handling>\n- **classifyHandoffIfNeeded false failure:** Agent reports \"failed\" but error is `classifyHandoffIfNeeded is not defined` → Claude Code bug, not GSD. Spot-check (SUMMARY exists, commits present) → if pass, treat as success\n- **Agent fails mid-plan:** Missing SUMMARY.md → report, ask user how to proceed\n- **Dependency chain breaks:** Wave 1 fails → Wave 2 dependents likely fail → user chooses attempt or skip\n- **All agents in wave fail:** Systemic issue → stop, report for investigation\n- **Checkpoint unresolvable:** \"Skip this plan?\" or \"Abort phase execution?\" → record partial progress in STATE.md\n</failure_handling>\n\n<resumption>\nRe-run `/gsd:execute-phase {phase}` → discover_plans finds completed SUMMARYs → skips them → resumes from first incomplete plan → continues wave execution.\n\nSTATE.md tracks: last completed plan, current wave, pending checkpoints.\n</resumption>\n"
